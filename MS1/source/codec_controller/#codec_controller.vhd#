-------------------------------------------------------------------------------
-- Title      : codec_controller
-- Project    : DTP2 Synthesizer Projekt
-------------------------------------------------------------------------------
-- File       : codec_controller.vhd
-- Author     : <Heinzen> Marco Heinzen (heinzma2@students.zhaw.ch)
-- Company    :ZHAW
-- Created    : 2019-03-08
-- Platform   : Windows 10
-- Standard   : VHDL'08
-------------------------------------------------------------------------------
-- Description: controller block for the audio codec
-------------------------------------------------------------------------------
-- Copyright (c) 2019
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author          Description
-- 2018-03-08  1.0      Heinzen         Created
-- 2018-03-09  1.1      Heinzen         minor changes and comments added
-------------------------------------------------------------------------------

-- Library & Use Statements
-------------------------------------------
library ieee;
use ieee.std_logic_1164.all;            -- standard lib
use ieee.numeric_std.all;               -- standard lib
use work.reg_table_pkg.all;  -- predifined registry with bits set for different audio applications

-- Entity Declaration
-------------------------------------------
-- codec controller prestatement: codec controller receives 3 switches via sw_sync_i (3bit bus) 
-- depending on the switch combination, different codec presets are loaded via i2c
-- the fsm state machine controls the i2c bus and loads the preset and decides if the acknowledge bit is correctly set
-- / if the communication was succesfull


entity codec_controller is

  port (
    sw_sync_i    : in  std_logic_vector(2 downto 0);  -- input for the switches
    initialize_i : in  std_logic;       -- input for initialisation
    write_done_i : in  std_logic;       -- input if writing is done
    ack_error_i  : in  std_logic;       -- acknowledge bit error input
    clk          : in  std_logic;       -- system clock input (50 MHz)
    reset_n      : in  std_logic;  -- reset input for reseting the fsm to idle and outputs to '0'
    write_o      : out std_logic;       --serial write output
    mute_o       : out std_logic;       -- mute output
    write_data_o : out std_logic_vector(15 downto 0));  -- 16bit write output vector with address and data bits

end codec_controller;


-- Architecture
-------------------------------------------
architecture rtl of codec_controller is
-- Types
  type codec_status is (idle, prepare, startWrite, waitAck);

-- Signals
  signal currentStat            : codec_status;  -- signal: state of fsm machine
  signal nextStat               : codec_status;  -- signal: next state of the fsm machine
  signal count                  : unsigned(6 downto 0);  -- signal: 7bit count register
  signal nextcount              : unsigned(6 downto 0);  -- signal: next 7bit count register
  signal event_control          : std_logic_vector(2 downto 0);  -- signal: event_control register consist of the 3bit switches input
  signal next_event_control     : std_logic_vector(2 downto 0);  -- signal: next_event_control next rei^gister 3bit switches
  signal write_data_buffer      : std_logic_vector(15 downto 0);  -- signal: write output buffer register
  signal next_write_data_buffer : std_logic_vector(15 downto 0);  -- signal: next write output buffer register

begin


  -- Process for FSM and count
  clocked : process(clk, reset_n, nextStat)
  begin
    -- Reset for Counter, Output and FSM , override with '0'
    if reset_n = '0' then
      currentStat       <= idle;
      event_control     <= (others => '0');
      count             <= (others => '0');
      write_data_buffer <= (others => '0');

    -- on rising edge states are shifted and count is increased
    elsif rising_edge(clk) then
      currentStat       <= nextStat;
      count             <= nextcount;
      event_control     <= next_event_control;
      write_data_buffer <= next_write_data_buffer;
    end if;

  end process clocked;


  -- Process for sending data to i2c master
  sendparallel : process (all)
  begin
    -- Default Statements
    nextStat               <= currentStat;
    nextcount              <= count;
    next_event_control     <= event_control;
    next_write_data_buffer <= write_data_buffer;
    write_o                <= '0';

    case currentStat is
      when idle =>                      -- default state
        next_event_control <= sw_sync_i;
        if initialize_i = '0' then  -- change state to prepare if initialize_i signal is '1'
          nextStat <= prepare;
          case event_control is         -- set array entry to 9
            when "000"  => nextcount <= to_unsigned(9, 7);
            when "001"  => nextcount <= to_unsigned(9, 7);
            when "010"  => nextcount <= to_unsigned(9, 7);
            when "011"  => nextcount <= to_unsigned(9, 7);
            when "100"  => nextcount <= to_unsigned(9, 7);
            when others => nextStat  <= idle;
          end case;
        end if;

      when prepare =>
        nextStat <= startWrite;
        -- writing data in output register
        case event_control is  -- switch between different stored commands
          when "000" => next_write_data_buffer <= std_logic_vector(count) & C_W8731_ANALOG_BYPASS(to_integer(count));
          when "001" => next_write_data_buffer <= std_logic_vector(count) & C_W8731_ANALOG_MUTE_RIGHT(to_integer(count));
          when "010" => next_write_data_buffer <= std_logic_vector(count) & C_W8731_ANALOG_MUTE_LEFT(to_integer(count));
          when "011" => next_write_data_buffer <= std_logic_vector(count) & C_W8731_ANALOG_MUTE_BOTH(to_integer(count));
          when "100" => next_write_data_buffer <= std_logic_vector(count) & C_W8731_ADC_DAC_0DB_48K(to_integer(count));

          when others =>
            nextStat  <= idle;
            nextcount <= (others => '0');
        end case;

      -- start sending data
      when startWrite =>
        write_o  <= '1';
        nextStat <= waitAck;

      -- wait till data are received
      when waitAck =>
        if (write_done_i = '1') then    -- sending next data package
          if (count = 0) then           -- go to idle if all data is sent
            nextStat               <= idle;
            next_write_data_buffer <= (others => '0');
          else
            nextStat  <= prepare;
            nextcount <= count -1;      -- reduce count by 1
          end if;
        elsif (ack_error_i = '1') then  -- resending data if error is received
          nextStat <= prepare;
        end if;

      when others =>
        nextStat <= idle;

    end case;
  end process;

  -- outputs
  write_data_o <= write_data_buffer;


end architecture;
